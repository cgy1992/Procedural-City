#define __NO_STD_VECTOR
#define __CL_ENABLE_EXCEPTIONS
#include "CLTextureBuilder.h"
#include <CL/cl.hpp>

CLTextureBuilder::CLTextureBuilder()
{
	_pixels = 0;
	_texture = 0;
}

CLTextureBuilder::~CLTextureBuilder()
{
	if(_pixels != 0)
		delete _pixels;
}

bool CLTextureBuilder::run(int texWidth, int texHeight, std::string clFile)
{
	_width = texWidth;
	_height = texHeight;

	std::string fileLoc = "opencl/textures/";
	fileLoc += clFile;
	fileLoc += ".cl";

	try
	{
		//OpenCL initialization
		cl::vector<cl::Platform> platforms;
		cl::vector<cl::Device> devices;
		cl::vector<cl::Kernel> kernels;

		cl::Platform::get(&platforms);

		platforms[0].getDevices(CL_DEVICE_TYPE_GPU, &devices);
		cl::Context context(devices);
		
		cl::CommandQueue queue(context, devices[0]);

		//Source code loading and compilation
		std::string sourceCode = Resources::getTextFileAsString(fileLoc);

		cl::Program::Sources source(1, std::make_pair(sourceCode.c_str(), sourceCode.length() + 1));

		cl::Program program(context, source);
		program.build(devices);

		//Create a buffer to hold the ARGB pixels generated by the OpenCL script
		cl::Buffer pixelBuffer(context, CL_MEM_WRITE_ONLY, sizeof(unsigned char) * texWidth * texHeight * 4);

		cl::Kernel kernel(program, "generate_texture");
		kernel.setArg(0, pixelBuffer);
		kernel.setArg(1, sizeof(int), &_width);
		kernel.setArg(2, sizeof(int), &_height);

		//Do calculations for every pixel
		cl::NDRange global(texWidth * texHeight);
		cl::NDRange local(1);

		queue.enqueueNDRangeKernel(kernel, cl::NullRange, global, local);

		_pixels = new unsigned char[texWidth * texHeight * 4];
		queue.enqueueReadBuffer(pixelBuffer, CL_TRUE, 0, sizeof(unsigned char) * texWidth * texHeight * 4, _pixels);

		//Reset any previous texture
		_texture = 0;

		//Inform caller that script has been run successfully
		return true;
	}catch(cl::Error e)
	{
		std::cout<<"CL Error: "<<e.err()<<", "<<e.what()<<std::endl;
		return false;
	}

}

irr::video::ITexture* CLTextureBuilder::getTexture(irr::video::IVideoDriver* driver, std::string textureName)
{

	if(_texture != 0)
		return _texture;

	if(_pixels != 0)
	{
		irr::video::IImage* img = driver->createImageFromData(irr::video::ECF_A8R8G8B8, irr::core::dimension2du(_width, _height), _pixels);
		_texture = driver->addTexture(textureName.c_str(), img);

		//Clean up
		img->drop();
		delete _pixels;
		_pixels = 0;

		return _texture;
	}

	return 0;
}